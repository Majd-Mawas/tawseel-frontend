<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Center Menu</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      type="text/css"
      media="screen"
      href="./css/restaurant.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css?family=Yesteryear&display=swap"
      rel="stylesheet"
    />
    <!-- Leaflet CSS and JS (replacing Google Maps API) -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet Routing Machine for route calculation -->
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"
    />

    <script>
      // const url = "http://tawseel.test";
      const url = "https://tawseel.circleteams.com";

      // Get restaurant ID from URL params
      const urlParams = new URLSearchParams(window.location.search);
      const center = urlParams.get("id");

      // Initialize cart from localStorage or create empty cart
      let cart = JSON.parse(localStorage.getItem("cart")) || [];

      // Update cart count in the header
      function updateCartCount() {
        const cartCount = cart.reduce(
          (total, item) => total + item.quantity,
          0
        );
        const cartCountElement = document.getElementById("cartCount");

        if (cartCountElement) {
          cartCountElement.textContent = cartCount;
          cartCountElement.style.display = cartCount > 0 ? "flex" : "none";
        }
      }

      // Save cart to localStorage
      function saveCart() {
        localStorage.setItem("cart", JSON.stringify(cart));
        updateCartCount();
      }

      // Add item to cart
      function addToCart(meal) {
        const existingItem = cart.find((item) => item.id === meal.id);

        if (existingItem) {
          existingItem.quantity += 1;
        } else {
          cart.push({
            id: meal.id,
            name: meal.name,
            price: meal.price,
            image:
              meal.media[0]?.original_url || "assets/images/default-meal.jpg",
            quantity: 1,
          });
        }

        saveCart();
        updateQuantityDisplay(meal.id);
      }

      // Remove item from cart
      function removeFromCart(mealId) {
        const existingItemIndex = cart.findIndex((item) => item.id === mealId);

        if (existingItemIndex !== -1) {
          if (cart[existingItemIndex].quantity > 1) {
            cart[existingItemIndex].quantity -= 1;
          } else {
            cart.splice(existingItemIndex, 1);
          }

          saveCart();
          updateQuantityDisplay(mealId);
        }
      }

      // Update quantity display for a specific meal
      function updateQuantityDisplay(mealId) {
        const quantityElement = document.querySelector(
          `.quantity-display[data-meal-id="${mealId}"]`
        );
        if (quantityElement) {
          const cartItem = cart.find((item) => item.id === mealId);
          quantityElement.textContent = cartItem ? cartItem.quantity : 0;

          // Show/hide quantity display based on whether item is in cart
          const quantityContainer = quantityElement.closest(
            ".quantity-container"
          );
          if (quantityContainer) {
            quantityContainer.classList.toggle(
              "has-items",
              cartItem && cartItem.quantity > 0
            );
          }
        }
      }

      // Update all quantity displays
      function updateAllQuantityDisplays() {
        document.querySelectorAll(".quantity-display").forEach((element) => {
          const mealId = parseInt(element.dataset.mealId);
          const cartItem = cart.find((item) => item.id === mealId);
          element.textContent = cartItem ? cartItem.quantity : 0;

          // Show/hide quantity display based on whether item is in cart
          const quantityContainer = element.closest(".quantity-container");
          if (quantityContainer) {
            quantityContainer.classList.toggle(
              "has-items",
              cartItem && cartItem.quantity > 0
            );
          }
        });
      }

      // Fetch restaurant meals when page loads
      window.onload = async function () {
        try {
          const response = await fetch(`${url}/api/centers/${center}`);
          if (response.ok) {
            const data = await response.json();
            console.log(data);

            displayMeals(data.meals);
            setupFilterButtons(data.meals);
            updateCartCount();
            updateAllQuantityDisplays();
          } else {
            console.error("Failed to fetch meals");
          }
        } catch (error) {
          console.error("Error fetching meals:", error);
        }
      };

      function setupFilterButtons(meals) {
        const categories = [
          ...new Set(meals.map((meal) => meal.category.name)),
        ];
        const filterContainer = document.querySelector(".filter-buttons");

        // Add "All" button
        filterContainer.innerHTML = `
        <button class="filter-btn active" data-category="all">All Items</button>
      `;

        // Add category buttons
        categories.forEach((category) => {
          filterContainer.innerHTML += `
          <button class="filter-btn" data-category="${category.toLowerCase()}">${category}</button>
        `;
        });

        // Setup filter functionality
        const filterButtons = document.querySelectorAll(".filter-btn");
        filterButtons.forEach((button) => {
          button.addEventListener("click", () => {
            const category = button.dataset.category;
            filterButtons.forEach((btn) => btn.classList.remove("active"));
            button.classList.add("active");

            const menuItems = document.querySelectorAll(".menu-item");
            menuItems.forEach((item) => {
              if (category === "all" || item.dataset.category === category) {
                item.style.display = "block";
              } else {
                item.style.display = "none";
              }
            });
          });
        });
      }

      function displayMeals(meals) {
        const container = document.querySelector(".cards");
        container.innerHTML = "";

        meals.forEach((meal) => {
          const cartItem = cart.find((item) => item.id === meal.id);
          const quantity = cartItem ? cartItem.quantity : 0;
          const hasItems = quantity > 0;

          container.innerHTML += `
          <div class="card cards_item menu-item" data-category="${meal.category.name.toLowerCase()}">
            <div class="card_image">
              <img src="${
                meal.media[0]?.original_url || "assets/images/default-meal.jpg"
              }" alt="${meal.name}" />
              <span class="card_price"><span></span>${meal.price}</span>
            </div>
            <div class="card_content">
              <h2 class="card_title">${meal.name}</h2>
              <div class="card_text">
                <p>${meal.description}</p>
              </div>
            </div>
            <div class="add">
              <button class="add-btn" data-meal-id="${meal.id}">
                <span class="fa fa-plus-circle" style="font-size:24px"></span>
              </button>
              <div class="quantity-container ${hasItems ? "has-items" : ""}">
                <span class="quantity-display" data-meal-id="${
                  meal.id
                }">${quantity}</span>
              </div>
              <button class="remove-btn ${
                hasItems ? "active" : ""
              }" data-meal-id="${meal.id}">
                <span class="fa fa-minus-circle" style="font-size:24px"></span>
              </button>
            </div>
          </div>
        `;
        });

        // Add event listeners for add and remove buttons
        document.querySelectorAll(".add-btn").forEach((button) => {
          button.addEventListener("click", function () {
            const mealId = parseInt(this.dataset.mealId);
            const meal = meals.find((m) => m.id === mealId);
            if (meal) {
              addToCart(meal);

              // Add animation effect
              this.classList.add("clicked");
              setTimeout(() => {
                this.classList.remove("clicked");
              }, 300);
            }
          });
        });

        document.querySelectorAll(".remove-btn").forEach((button) => {
          button.addEventListener("click", function () {
            const mealId = parseInt(this.dataset.mealId);
            removeFromCart(mealId);

            // Add animation effect
            this.classList.add("clicked");
            setTimeout(() => {
              this.classList.remove("clicked");
            }, 300);
          });
        });
      }
    </script>
  </head>

  <body>
    <div class="header">
      <a href="home.html">
        <span style="font-size: 40px; color: white">&#8592;</span></a
      >
      <h1 id="restaurantName">Center Menu</h1>
      <div class="cart-icon-container">
        <a href="#" id="cartLink">
          <i
            class="fa fa-shopping-cart cart-icon"
            style="font-size: 36px; color: white"
          ></i>
          <span id="cartCount" class="cart-count">0</span>
        </a>
      </div>
    </div>

    <div class="container">
      <span>Center Items</span>
      <div class="filter-buttons">
        <!-- Filter buttons will be dynamically inserted here -->
      </div>
    </div>

    <div class="main">
      <ul class="cards">
        <!-- Menu items will be dynamically inserted here -->
      </ul>
    </div>

    <!-- Cart Modal (since there's no cart page) -->
    <div id="cartModal" class="modal">
      <div class="modal-content">
        <span class="close-modal">&times;</span>
        <h2>Your Cart</h2>
        <div id="cartItems"></div>
        <div class="cart-total">
          <h3>Total:<span id="cartTotalAmount">0.00</span></h3>
          <button id="checkoutBtn" class="checkout-btn">Checkout</button>
        </div>
        <!-- Add map container -->
        <div id="mapContainer" style="display: none; margin-top: 20px">
          <h3>Delivery Route</h3>
          <div
            id="orderDetails"
            style="
              margin-bottom: 15px;
              padding: 10px;
              background-color: #f8f9fa;
              border-radius: 5px;
            "
          >
            <div>
              <strong>Total Price:</strong> $<span id="orderTotalPrice"
                >0.00</span
              >
            </div>
            <div>
              <strong>Delivery Fee:</strong> $<span id="orderDeliveryFee"
                >0.00</span
              >
            </div>
            <div>
              <strong>Estimated Delivery Time:</strong>
              <span id="orderDeliveryTime">0</span> minutes
            </div>
          </div>
          <div id="map" style="height: 300px; width: 100%"></div>
        </div>
      </div>
    </div>

    <script>
      function calculateAStarPath(start, end, gridSize = 20) {
        console.log("Calculating A* path from", start, "to", end);

        function heuristic(a, b) {
          const R = 6371;
          const dLat = ((b[0] - a[0]) * Math.PI) / 180;
          const dLon = ((b[1] - a[1]) * Math.PI) / 180;
          const lat1 = (a[0] * Math.PI) / 180;
          const lat2 = (b[0] * Math.PI) / 180;

          const x = dLon * Math.cos((lat1 + lat2) / 2);
          const y = dLat;
          return Math.sqrt(x * x + y * y) * R;
        }

        function createGrid(start, end, size) {
          const grid = [];
          const latStep = (end[0] - start[0]) / size;
          const lngStep = (end[1] - start[1]) / size;

          for (let i = 0; i <= size; i++) {
            for (let j = 0; j <= size; j++) {
              const lat = start[0] + i * latStep;
              const lng = start[1] + j * lngStep;
              grid.push([lat, lng]);
            }
          }

          return grid;
        }

        class Node {
          constructor(position, parent = null) {
            this.position = position;
            this.parent = parent;
            this.g = parent
              ? parent.g + heuristic(parent.position, position)
              : 0;
            this.h = heuristic(position, end);
            this.f = this.g + this.h;
          }
        }

        const grid = createGrid(start, end, gridSize);

        const openSet = [new Node(start)];
        const closedSet = [];

        function getNeighbors(node, grid) {
          return grid.filter((point) => {
            const distance = heuristic(node.position, point);
            return distance > 0 && distance < 0.5;
          });
        }

        while (openSet.length > 0) {
          let currentIndex = 0;
          for (let i = 0; i < openSet.length; i++) {
            if (openSet[i].f < openSet[currentIndex].f) {
              currentIndex = i;
            }
          }

          const current = openSet[currentIndex];

          if (heuristic(current.position, end) < 0.1) {
            const path = [];
            let temp = current;
            while (temp) {
              path.push(temp.position);
              temp = temp.parent;
            }
            return path.reverse();
          }

          openSet.splice(currentIndex, 1);
          closedSet.push(current);

          const neighbors = getNeighbors(current, grid);
          for (const neighborPos of neighbors) {
            if (
              closedSet.some(
                (node) => heuristic(node.position, neighborPos) < 0.01
              )
            ) {
              continue;
            }

            const neighbor = new Node(neighborPos, current);

            const openNode = openSet.find(
              (node) => heuristic(node.position, neighborPos) < 0.01
            );
            if (openNode && neighbor.g >= openNode.g) {
              continue;
            }

            if (!openNode) {
              openSet.push(neighbor);
            } else {
              openNode.parent = current;
              openNode.g = neighbor.g;
              openNode.f = openNode.g + openNode.h;
            }
          }

          if (closedSet.length > 1000) {
            console.warn("A* algorithm reached iteration limit");
            break;
          }
        }

        console.warn("A* could not find optimal path, returning direct line");
        return [start, end];
      }
    </script>

    <script>
      const cartLink = document.getElementById("cartLink");
      const cartModal = document.getElementById("cartModal");
      const closeModal = document.querySelector(".close-modal");

      function displayCartItems() {
        const cartItemsContainer = document.getElementById("cartItems");
        const cartTotalElement = document.getElementById("cartTotalAmount");

        if (cart.length === 0) {
          cartItemsContainer.innerHTML =
            '<p class="empty-cart">Your cart is empty</p>';
          cartTotalElement.textContent = "0.00";
          return;
        }

        let total = 0;
        cartItemsContainer.innerHTML = "";

        cart.forEach((item) => {
          const itemTotal = item.price * item.quantity;
          total += itemTotal;

          cartItemsContainer.innerHTML += `
            <div class="cart-item">
              <img src="${item.image}" alt="${
            item.name
          }" class="cart-item-image">
              <div class="cart-item-details">
                <h3>${item.name}</h3>
                <p>${item.price} x ${item.quantity}</p>
              </div>
              <div class="cart-item-total">$${itemTotal.toFixed(2)}</div>
              <button class="remove-cart-item" data-id="${item.id}">
                <span class="fa fa-trash"></span>
              </button>
            </div>
          `;
        });

        cartTotalElement.textContent = total.toFixed(2);

        document.querySelectorAll(".remove-cart-item").forEach((button) => {
          button.addEventListener("click", function () {
            const itemId = parseInt(this.dataset.id);
            const itemIndex = cart.findIndex((item) => item.id === itemId);

            if (itemIndex !== -1) {
              cart.splice(itemIndex, 1);
              saveCart();
              displayCartItems();
              updateAllQuantityDisplays();
            }
          });
        });
      }

      cartLink.addEventListener("click", function (e) {
        e.preventDefault();
        displayCartItems();
        cartModal.style.display = "block";
      });

      closeModal.addEventListener("click", function () {
        cartModal.style.display = "none";
      });

      window.addEventListener("click", function (event) {
        if (event.target === cartModal) {
          cartModal.style.display = "none";
        }
      });

      document
        .getElementById("checkoutBtn")
        .addEventListener("click", function () {
          if (cart.length === 0) {
            alert("Your cart is empty");
            return;
          }

          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
              function (position) {
                const items = cart.map((item) => ({
                  meal_id: item.id,
                  quantity: item.quantity,
                }));

                const orderData = {
                  center_id: center,
                  items: items,
                  latitude: position.coords.latitude,
                  longitude: position.coords.longitude,
                };

                fetch(`${url}/api/checkout`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Accept: "application/json",
                    Authorization: `Bearer ${localStorage.getItem("token")}`,
                  },
                  body: JSON.stringify(orderData),
                })
                  .then((response) => {
                    if (response.ok) {
                      return response.json();
                    }
                    throw new Error("Checkout failed");
                  })
                  .then((data) => {
                    console.log(data.data.restaurant);

                    alert("Order placed successfully!");

                    if (data.data) {
                      document.getElementById("orderTotalPrice").textContent = (
                        (data.data.total_price || 0) / 100
                      ).toFixed(2);
                      document.getElementById("orderDeliveryFee").textContent =
                        ((data.data.delivery_fee || 0) / 100).toFixed(2);
                      document.getElementById("orderDeliveryTime").textContent =
                        data.data.delivery_time_estimate || "N/A";
                    }
                    if (
                      data.data.restaurant &&
                      data.data.restaurant.latitude &&
                      data.data.restaurant.longitude
                    ) {
                      document.getElementById("mapContainer").style.display =
                        "block";

                      const userLatLng = [
                        position.coords.latitude,
                        position.coords.longitude,
                      ];
                      const centerLatLng = [
                        parseFloat(data.data.restaurant.latitude),
                        parseFloat(data.data.restaurant.longitude),
                      ];

                      const map = L.map("map").setView(userLatLng, 13);

                      L.tileLayer(
                        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                        {
                          attribution: "© OpenStreetMap contributors",
                        }
                      ).addTo(map);

                      L.marker(userLatLng)
                        .addTo(map)
                        .bindPopup("Your Location")
                        .openPopup();

                      L.marker(centerLatLng)
                        .addTo(map)
                        .bindPopup(
                          data.data.restaurant.name || "Center Location"
                        );

                      const routingControl = L.Routing.control({
                        waypoints: [
                          L.latLng(userLatLng),
                          L.latLng(centerLatLng),
                        ],
                        routeWhileDragging: false,
                        showAlternatives: false,
                        fitSelectedRoutes: true,
                        lineOptions: {
                          styles: [{ color: "#0073FF", weight: 4 }],
                        },
                      }).addTo(map);

                      setTimeout(() => {
                        map.invalidateSize();
                      }, 100);
                    } else {
                      console.error(
                        "Center location data not available in the response"
                      );
                    }

                    cart = [];
                    saveCart();
                  })
                  .catch((error) => {
                    console.error("Error during checkout:", error);
                    alert("Failed to place order. Please try again.");
                  });
              },
              function (error) {
                console.error("Error getting location:", error);
                alert(
                  "We need your location to process the order. Please enable location services and try again."
                );
              }
            );
          } else {
            alert(
              "Geolocation is not supported by this browser. We need your location to process the order."
            );
          }
        });
    </script>
  </body>
</html>
